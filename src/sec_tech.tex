\lstset{style=fsharpstyle}

\section{Используемые технологии} 
\label{sec:practice:technology_used}

Выбор технологий является важным предварительным этапом разработки сложных информационных систем.
Платформа и язык программирования, на котором будет реализована система, заслуживает большого внимания, так как исследования показали, что выбор языка программирования влияет на производительность труда программистов и качество создаваемого ими кода~\cite[c.~59]{mcconnell_2005}.

Ниже перечислены некоторые факторы, повлиявшие на выбор технологий:
\begin{itemize}
\item Разрабатываемое ПО должно работать на операционной системе Windows~7 и более новых версиях системы.
\item Среди различных платформ разработки имеющийся программист лучше всего знаком с разработкой на платформе \dotnet{}.
\item Дальнейшей поддержкой проекта, возможно, будут заниматься разработчики, не принимавшие участие в выпуске первой версии.
\item Имеющийся разработчик имеет опыт работы с объекто"=ориентированными и с функциональными языками программирования.
\end{itemize}

Основываясь на опыте работы имеющихся программистов разрабатывать ПО целесообразно на платформе \dotnet{}.
Приняв во внимание необходимость обеспечения доступности дальнейшей поддержки ПО, возможно, другой командой программистов, целесообразно не использовать малоизвестные и сложные языки программирования.
С учетом этого фактора выбор языков программирования сужается до четырех официально поддерживаемых Microsoft и имеющих изначальную поддержку в Visual Studio~2012: \cppcli{}, \csharp{}, \vbnet{} и \fsharp{}.
Необходимость использования низкоуровневых возможностей \cppcli{} в разрабатываемом ПО отсутствует, следовательно данный язык можно исключить из списка кандидатов.
\vbnet{} уступает по удобству использования двум другим кандидатам из нашего списка.
Оставшиеся два языка программирования \csharp{} и \fsharp{} являются первостепенным, элегантными, мультипарадигменными языками программирования для платформы \dotnet.
Таким образом, с учетом вышеперечисленных факторов, целесообразно остановить выбор на следующих технологиях:
\begin{itemize}
  \item операционная система Windows~7;
  \item платформа разработки \dotnet{};
  \item языки программирования \csharp{} и \fsharp{}.
\end{itemize}
Для реализации поставленной задачи нет необходимости в использовании каких"=либо прикладных библиотек для создания настольных или веб"=приложений, достаточно использовать стандартные библиотеки указанных выше языков.
Поддержка платформой \dotnet{} различных языков программирования позволяет использовать язык, который наиболее просто и <<красиво>> позволяет решить возникающую задачу.
Разрабатываемое программное обеспечение в некоторой степени использует данное преимущество платформы.
Язык \csharp{} больше подходит для создания высокоуровнего дизайна проложения (иерархия классов и интерфейсов, организация пространств имен и публичного программного интерфейса), язык \fsharp{} "--- для реализации логики приложения, функций и методов~\cite{fsdg_2010}, прототипирования различных идей.
В разрабатываемом программном продукте \csharp{} используется для предоставления удобного программного интерфейса, \fsharp{} "--- для прототипирования и реализации вычислительной логики.
Далее проводится характеристика используемых технологий и языков программирования более подробно.



\subsection{Программная платформа \dotnet}
\label{sub:practice:microsoft_net}
Программная платформа \dotnet{} является одной из реализаций стандарта ECMA-335~\cite{ecma_335} и является современным инструментом создания клиентских и серверных приложений для операционной системы Windows.
Первая общедоступная версия \netfx{} вышла в феврале 2002 года.
С тех пор платформа активно эволюционировала и на данный момент было выпущено шесть версии данного продукта.
На данный момент номер последней версии \netfx{} "--- 4.5.
Платформа \dotnet{} была призвана решить некоторые наболевшие проблемы, скопившиеся на момент её выхода, в средствах разработки приложений под Windows. 
Ниже перечислены некоторые из них~\cite[с.~\Rmnum{14}\,--\,\Rmnum{17}]{richter_2007_ru}:
\begin{itemize}
  \item сложность создания надежных приложений;
  \item сложность развертывания и управления версиями приложений и библиотек;
  \item сложность создания переносимого ПО;
  \item отсутствие единой целевой платформы для создателей компиляторов;
  \item проблемы с безопасным исполнением непроверенного кода;
  \item великое множество различных технологий и языков программирования, которые не совместимы между собой.
\end{itemize}

Многие из этих проблем были решены.
Далее более подробно рассматривается внутреннее устройство \dotnet{}.

Основными составляющими компонентами \dotnet{} являются общая языковая исполняющая среда (Common Language Runtime) и стандартная библиотека классов (Framework Class Library).
CLR представляет из себя виртуальную машину и набор сервисов обслуживающих исполнение программ написанных для \dotnet{}.
Ниже приводится перечень задач, возлагаемых на CLR~\cite{marchenko_2007}:
\begin{itemize}
  \item загрузка и исполнение управляемого кода;
  \item управление памятью при размещении объектов;
  \item изоляция памяти приложений;
  \item проверка безопасности кода;
  \item преобразование промежуточного языка в машинный код;
  \item доступ к расширенной информации от типах "--- метаданным;
  \item обработка исключений, включая межъязыковые исключения;
  \item взаимодействие между управляемым и неуправляемым кодом (в том числе и COM"=объектами);
  \item поддержка сервисов для разработки (профилирование, отладка и т.\,д.).
\end{itemize}

Программы написанные для \dotnet{} представляют из себя набор типов взаимодействующих между собой.
\dotnet{} имеет общую систему типов (Common Type System, CTS).
Данная спецификация описывает определения и поведение типов создаваемых для \dotnet{}~\cite{richter_2012_en}.
В частности в данной спецификации описаны возможные члены типов, механизмы сокрытия реализации, правила наследования, типы"=значения и ссылочные типы, особенности параметрического полиморфизма и другие возможности предоставляемые CLI.
Общая языковая спецификация (Common Language Specification, CLS) "--- подмножество общей системы типов. 
Это набор конструкций и ограничений, которые являются руководством для создателей библиотек и компиляторов в среде \netfx{}.
Библиотеки, построенные в соответствии с CLS, могут быть использованы из любого языка программирования, поддерживающего CLS. 
Языки, соответствующие CLS (к их числу относятся языки \csharp{}, \vbnet{}, \cppcli{}), могут интегрироваться друг с другом. CLS "--- это основа межъязыкового взаимодействия в рамках платформы \dotnet{}~\cite{marchenko_2007}.

Некоторые из возможностей, предоставляемых \dotnet{}: верификация кода, расширенная информация о типах во время исполнения, сборка мусора, безопасность типов, "--- невозможны без наличия подробных метаданных о типах из которых состоит исполняемая программа.
Подробные метаданные о типах генерируются компиляторами и сохраняются в результирующих сборках.
Сборка "--- это логическая группировка одного или нескольких управляемых модулей или файлов ресурсов, является минимальной единицей с точки зрения повторного использования, безопасности и управлениями версиями~\cite[с.~6]{richter_2012_en}.

Одной из особенностей \dotnet{}, обеспечивающей переносимость программ без необходимости повторной компиляции, является представление исполняемого кода приложений на общем промежуточном языке (Common Intermediate Language, CIL). 
Промежуточный язык является бестиповым, стековым, объекто"=ориентированным ассемблером~\cite[с.~16\,--\,17]{richter_2012_en}.
Данный язык очень удобен в качестве целевого языка для создателей компиляторов и средств автоматической проверки кода для платформы \dotnet{}, также язык довольно удобен для чтения людьми.
Наличие промежуточного языка и необходимость создания производительных программ подразумевают наличие преобразования промежуточного кода в машинный код во время исполнения программы.
Одним из компонентов общей языковой исполняющей среды, выполняющим данное преобразование, является компилятор времени исполнения (Just-in-time compiler) транслирующий промежуточный язык в машинные инструкции, специфические для архитектуры компьютера на котором исполняется программа.

Ручное управление памятью всегда являлось очень кропотливой и подверженной ошибкам работой.
Ошибки в управлении памятью являются одними из наиболее сложных в устранении типами программных ошибок, также эти ошибки обычно приводят к непредсказуемому поведению программы, поэтому в \dotnet{} управление памятью происходит автоматически~\cite[с.~505\,--\,506]{richter_2012_en}.
Автоматическое управление памятью является механизмом поддержания иллюзии бесконечности памяти.
Когда объект данных перестает быть нужным, занятая под него память автоматически освобождается и используется для построения новых объектов данных.
Имеются различные методы реализации такого автоматического распределения памяти~\cite[с.~489]{sicp_2006_ru}.
В~\dotnet{} для автоматического управления памятью используется механизм сборки мусора (garbage collection).
Существуют различные алгоритмы сборки мусора со своими достоинствами и недостатками. 
В \dotnet{} используется алгоритм пометок (mark and sweep) в сочетании с различными оптимизациями, такими как, например, разбиение всех объектов по поколениям и использование различных куч для больших и малых объектов.

Ниже перечислены, без приведения подробностей, некоторые важные функции исполняемые общей языковой исполняющей средой:
\begin{itemize}
  \item обеспечение многопоточного исполнения программы;
  \item поддержание модели памяти, принятой в CLR;
  \item поддержка двоичной сериализации;
  \item управление вводом и выводом;
  \item структурная обработка исключений;
  \item возможность размещения исполняющей среды внутри других процессов.
\end{itemize}

Как уже упоминалось выше, большую ценностью для \dotnet{} представляет библиотека стандартных классов "--- соответствующая CLS"=спецификации объектно"=ориентированная библиотека классов, интерфейсов и системы типов (типов"=значений), которые включаются в состав платформы \dotnet{}.
Эта библиотека обеспечивает доступ к функциональным возможностям системы и предназначена служить основой при разработке .NET"=приложений, компонент, элементов управления~\cite{marchenko_2007}.



\subsection{Язык программирования \csharp{}}
\label{sub:practice:csharp_overview}
\csharp{} "--- объектно"=ориентированный, типо"=безопасный язык программирования общего назначения.
Язык создавался с целью повысить продуктивность программистов.
Для достижения этой цели в языке гармонично сочетаются простота, выразительность и производительность промежуточного кода, получаемого после компиляции.
Главным архитектором и идеологом языка с первой версии является Андрес Хейлсберг (создатель Turbo Pascal и архитектор Delphi).
Язык \csharp{} является платформенно нейтральным, но создавался для хорошей работы с \dotnet{}~\cite{albahari_2012_en}.
Этот язык сочетает простой синтаксис, похожий на синтаксис языков \cpp{} и \java{}, и полную поддержку всех современных объектно-ориентированных концепций и подходов. В качестве ориентира при разработке языка было выбрано безопасное программирование, нацеленное на создание надежного и простого в сопровождении кода~\cite{volosevich_cs_2011}.

Язык имеет богатую поддержку парадигмы объекто"=ориентированного программирования, включающую поддержку инкапсуляции, наследования и полиморфизма.
Отличительными чертами \csharp{} с точки зрения ОО парадигмы являются:
\begin{itemize}
  \item Унифицированная система типов. 
        В \csharp{} сущность, содержащая данные и методы их обработки, называется типом.
        В \csharp{} все типы, являются ли они пользовательскими типами, или примитивами, такими как число, производны от одного базового класса.
  \item Классы и интерфейсы.
        В классической объекто"=ориентированной парадигме существуют только классы.
        В \csharp{} дополнительно существуют и другие типы, например, интерфейсы.
        Интерфейс "--- это сущность напоминающая классы, но содержащая только определения членов.
        Конкретная реализация указанных членов интерфейса происходит в типах, реализующих данный интерфейс.
        В частности интерфейсы могут быть использованы при необходимости проведения множественного наследования (в отличие от языков \cpp{} и Eiffel, \csharp{} не поддерживает множественное наследование классов).
  \item Свойства, методы и события.
        В чистой объекто"=ориентированной парадигме все функции являются методами.
        В \csharp{} методы являются лишь одной из возможных разновидностей членов типа, в \csharp{} типы также могут содержать свойства, события и другие члены.
        Свойство "--- это такая разновидность функций, которая инкапсулирует часть состояния объекта.
        Событие "--- это разновидность функций, которые реагируют на изменение состояния объекта~\cite{albahari_2012_en}.
\end{itemize}

В большинстве случаев \csharp{} обеспечивает безопасность типов в том смысле, что компилятор контролирует чтобы взаимодействие с экземпляром типа происходило согласно контракту, который он определяют.
Например, компилятор \csharp{} не скомпилирует код который обращается со строками, как если бы они были целыми числами.
Говоря более точно, \csharp{} поддерживает статическую типизацию, в том смысле что большинство ошибок типов обнаруживаются на стадии компиляции.
За соблюдение более строгих правил безопасности типов следит исполняющая среда.
Статическая типизация позволяет избавиться от широкого круга ошибок, возникающих из-за ошибок типов. 
Она делает написание и изменение программ более предсказуемыми и надежными, кроме того, статическая типизация позволяет существовать таким средствам как автоматическое дополнение кода и его предсказуемый статический анализ.
Еще одним аспектом типизации в \csharp{} является её строгость.
Строгая типизация означает, что правила типизации в языке очень <<сильные>>.
Например, язык не позволяет совершать вызов метода, принимающего целые числа, передавая в него вещественное число~\cite{albahari_2012_en}. 
Такие требования спасают от некоторых ошибок.

\csharp{} полагается на автоматическое управление памятью со стороны исполняющей среды, предоставляя совсем немного средств для управления жизненным циклом объектов.
Не смотря на это, в языке все же присутствует поддержка работы с указателями.
Данная возможность предусмотрена для случаев, когда критически важна производительность приложения или необходимо обеспечить взаимодействие с неуправляемым кодом~\cite{albahari_2012_en}. 

Как уже упоминалось \csharp{} не является платформенно зависимым языком.
Благодаря усилиям компании Xamarin возможно писать программы на языке \csharp{} не только для операционных систем Microsoft, но и ряда других ОС.
Существуют инструменты создания приложений на \csharp{} для серверных и мобильных платформ, например: iOS, Android, Linux и других.

Создатели языка \csharp{} не являются противниками привнесения в язык новых идей и возможностей, в отличии от создателей одного из конкурирующих языков.
Каждая новая версия компилятора языка привносит различные полезные возможности, которые отчаются требованиям индустрии. 
Далее приводится краткий обзор развития языка.

Первая версия \csharp{} была похожа по своим возможностям на \java{} 1.4, несколько их расширяя: так, в \csharp{} имелись свойства (выглядящие в коде как поля объекта, но на деле вызывающие при обращении к ним методы класса), индексаторы (подобные свойствам, но принимающие параметр как индекс массива), события, делегаты, циклы \lstinline!foreach!, структуры, передаваемые по значению, автоматическое преобразование встроенных типов в объекты при необходимости (boxing), атрибуты, встроенные средства взаимодействия с неуправляемым кодом (DLL, COM) и прочее~\cite{csharp_wiki_2013_ru}. 

Версия \dotnet{} 2.0 привнесла много новых возможностей в сравнении с предыдущей версией, что отразилось и на языках под эту платформу.
Проект спецификации \csharp{} 2.0 впервые был опубликован Microsoft в октябре 2003 года; в 2004 году выходили бета"=версии (проект с кодовым названием Whidbey), \csharp{} 2.0 окончательно вышел 7 ноября 2005 года вместе с Visual Studio 2005 и \dotnet{} 2.0. 
Ниже перечислены новые возможности в версии 2.0
\begin{itemize}
  \item Частичные типы (разделение реализации класса более чем на один файл).

  \item Обобщённые, или параметризованные типы (generics). 
  В отличие от шаблонов \cpp{}, они поддерживают некоторые дополнительные возможности и работают на уровне виртуальной машины.
  Вместе с тем, параметрами обобщённого типа не могут быть выражения, они не могут быть полностью или частично специализированы, не поддерживают шаблонных параметров по умолчанию, от шаблонного параметра нельзя наследоваться.

  \item Новая форма итератора, позволяющая создавать сопрограммы с помощью ключевого слова \lstinline[style=csharpinlinestyle]!yield!, подобно Python и Ruby.
  
  \item Анонимные методы, обеспечивающие функциональность замыканий.

  \item Оператор ??: \lstinline!return obj1 ?? obj2;! означает (в нотации \csharp{} 1.0) \lstinline[style=csharpinlinestyle]/return obj1!=null ? obj1 : obj2;/.

  \item Обнуляемые (nullable) типы"=значения (обозначаемые вопросительным знаком, например, \lstinline[style=csharpinlinestyle]!int? i = null;!), представляющие собой те же самые типы-значения, способные принимать также значение null. 
  Такие типы позволяют улучшить взаимодействие с базами данных через язык SQL.

  \item Поддержка 64-разрядных вычислений позволяет увеличить адресное пространство и использовать 64-разрядные примитивные типы данных~\cite{csharp_wiki_2013_ru}.
\end{itemize}

Третья версия языка имела одно большое нововведение "--- Language Integrated Query (LINQ), для реализации которого в языке дополнительно появилось множество дополнительных возможностей. 
Ниже приведены некоторые из них:
\begin{itemize}
  \item Ключевые слова \lstinline[style=csharpinlinestyle]!select!, \lstinline[style=csharpinlinestyle]!from!, \lstinline[style=csharpinlinestyle]!where!, позволяющие делать запросы из SQL, XML, коллекций и т.\,п.

  \item Инициализацию объекта вместе с его свойствами:
  \begin{lstlisting}[style=csharpinlinestyle]
Customer c = new Customer(); c.Name = "James"; c.Age=30;
  \end{lstlisting}
  можно записать как
  \begin{lstlisting}[style=csharpinlinestyle]
Customer c = new Customer { Name = "James", Age = 30 };
  \end{lstlisting}

  \item Лямбда-выражения:
  \begin{lstlisting}[style=csharpinlinestyle]
listOfFoo.Where(delegate(Foo x) { return x.size > 10; });
  \end{lstlisting}
  теперь можно записать как
  \begin{lstlisting}[style=csharpinlinestyle]
listOfFoo.Where(x => x.size > 10);
  \end{lstlisting}

  \item Деревья выражений "--- лямбда-выражения теперь могут быть представлены в виде структуры данных, доступной для обхода во время выполнения, тем самым позволяя транслировать строго типизированные \csharp{}-выражения в другие домены (например, выражения SQL).

  \item Вывод типов локальной переменной: \lstinline[style=csharpinlinestyle]!var x = "hello";! вместо \lstinline[style=csharpinlinestyle]!string x = "hello";!

  \item Безымянные типы: \lstinline[style=csharpinlinestyle]!var x = new { Name = "James" };!

  \item Методы-расширения "--- добавление метода в существующий класс с помощью ключевого слова \lstinline[style=csharpinlinestyle]!this! при первом параметре статической функции.

  \item Автоматические свойства: компилятор сгенерирует закрытое  поле и соответствующие аксессор и мутатор для кода вида
  \begin{lstlisting}[style=csharpinlinestyle]
public string Name { get; private set; }
  \end{lstlisting}

\end{itemize}
\csharp{} 3.0 совместим с \csharp{} 2.0 по генерируемому MSIL-коду; улучшения в языке "--- чисто синтаксические и реализуются на этапе компиляции~\cite{csharp_wiki_2013_ru}.

\vbnet{} 10.0 и \csharp{} 4.0 были выпущены в апреле 2010 года, одновременно с выпуском Visual Studio 2010.
Новые возможности в версии 4.0:
\begin{itemize}
  \item Возможность использования позднего связывания.
  \item Именованные и опциональные параметры.
  \item Новые возможности COM interop.
  \item Ковариантность и контрвариантность интерфейсов и делегатов.
  \item Контракты в коде (Code Contracts)~\cite{csharp_wiki_2013_ru}.
\end{itemize}

В \csharp{} 5.0 было немного нововведений, но они носят большую практическую ценность.
В новой версии появилась упрощенная поддержка выполнения асинхронных функций с помощью двух новых слов "---  \lstinline[style=csharpinlinestyle]!async! и \lstinline[style=csharpinlinestyle]!await!.
Ключевым словом \lstinline[style=csharpinlinestyle]!async! помечаются методы и лямбда"=выражения, которые внутри содержат ожидание выполнения асинхронных операций с помощью оператора \lstinline[style=csharpinlinestyle]!await!, который отвечает за преобразования кода метода во время компиляции.



\subsection{Язык программирования \fsharp{}}
\label{sub:practice:fsharp_overview}
\fsharp{} "--- это мультипарадигменный язык программирования, разработанный в подразделении Microsot Research и предназначенный для исполнения на платформе \dotnet{}. 
Он сочетает в себе выразительность функциональных языков, таких как OCaml и Haskell с возможностями и объектной моделью \dotnet{}.
История \fsharp{} началась в 2002 году, когда команда разработчиков из Microsoft Research под руководством Дона Сайма решила, что языки семейства ML вполне подходят для реализации функциональной парадигмы на платформе \dotnet{}.
Идея разработки нового языка появилась во время работы над реализацией обобщённого программирования для Common Language Runtime.
Известно, что одно время в качестве прототипа нового языка рассматривался Haskell, но из-за функциональной чистоты и более сложной системы типов потенциальный Haskell.NET не мог бы предоставить разработчикам простого механизма работы с библиотекой классов \netfx{}, а значит, не давал бы каких-то дополнительных преимуществ.
Как бы то ни было, за основу был взят OCaml, язык из семейства ML, который не является чисто функциональным и предоставляет возможности для императивного и объектно"=ориентированного программирования.
Однако Haskell хоть и не стал непосредственно родителем нового языка, тем не менее, оказал на него некоторое влияние. 
Например, концепция вычислительных выражений (computation expressions или workflows), играющих важную роль для асинхронного программирования и реализации DSL на \fsharp{}, позаимствована из монад Haskell~\cite{fsharp_pfp_issue_5}.

Следует также отметить, что на данный момент \fsharp{} является, пожалуй, единственным функциональным языком программирования, который продвигается одним из ведущих производителей в области разработки программного обеспечения.
Он позволяет использовать множество уже существующих библиотек, писать приложения для самых разных платформ и что не менее важно "---
делать всё это в современной IDE~\cite{fsharp_pfp_issue_5}.

Далее рассматриваются некоторые из возможностей предоставляемых \fsharp{}.

\subsubsection{Функциональная парадигма. }
\label{ssub:tech:fsharp_fun}
Будучи наследником славных традиций семейства языков ML, предоставляет полный набор инструментов функционального программирования: здесь есть алгебраические типы данных и функции высшего порядка, средства для композиции функций и неизменяемые структуры данных, а также частичное применение на пару с каррированием. 
Все функциональные возможности \fsharp{} реализованы в конечном итоге поверх общей системы типов \netfx{}.
Однако этот факт не обеспечивает удобства использования таких конструкций из других языков платформы.
При разработке собственных библиотек на \fsharp{} следует
предусмотреть создание объектно"=ориентированных обёрток, которые будет проще использовать из \csharp{} или \vbnet{}~\cite{fsharp_pfp_issue_5}. Рекомендации по проектированию таких библиотек приведены в~\cite{fsdg_2010}.

\subsubsection{Императивное программирование. }
\label{ssub:tech:fsharp_imperative}
В случаях, когда богатых функциональных возможностей не хватает, \fsharp{} предоставляет разработчику возможность использовать в коде прелести изменяемого состояния. 
Это как непосредственно изменяемые переменные, поддержка полей и свойств объектов стандартной библиотеки, так и явные циклы, а также изменяемые коллекции и типы данных.

\subsubsection{Объектно-ориентированная парадигма. }
\label{ssub:tech:fsharp_oop}
Объектно"=ориентированные возможности \fsharp{}, как и многое другое в этом языке, обусловлены необходимостью предоставить разработчикам возможность использовать стандартную библиотеку классов \netfx{}.
С поставленной задачей язык вполне справляется: можно как использовать библиотеки классов, реализованные на других .NET языках, так и разрабатывать свои
собственные.
Следует отметить, однако, что некоторые возможности ОО языков реализованы не
самым привычным образом~\cite{fsharp_pfp_issue_5}.

\subsubsection{Система типов. }
\label{ssub:tech:fsharp_types}
Каждая переменная, выражение или функция в \fsharp{} имеет тип. 
Можно считать, что тип "--- это некий контракт, поддерживаемый всеми объектами данного типа.
К примеру, тип переменной однозначно определяет диапазон значений этой переменной; тип функции говорит о том, какие параметры она принимает и значение какого типа она возвращает; тип объекта определяет то, как этот объект может быть использован~\cite{fsharp_pfp_issue_5}.

\fsharp{} "--- статически типизированный язык.
Это означает, что тип каждого выражения известен на этапе компиляции, и позволяет отслеживать ошибки, связанные с неправильным использованием объектов определенного типа, до запуска программы.
Помимо этого, \fsharp{} "--- язык программирования со строгой типизацией, а значит, в выражениях отсутствует неявное приведение типов.
Попытка использовать целое число там, где компилятор ожидает увидеть число с плавающей точкой, приведёт к ошибке компиляции~\cite{fsharp_pfp_issue_5}.

\subsubsection{Вывод типов. } 
\label{ssub:tech:fsharp_typeinference}
В отличие от большинства других промышленных языков программирования, \fsharp{} не требует явно указывать типы всех значений.
Механизм вывода типов позволяет определить недостающие типы значений, глядя на их использование.
При этом некоторые значения должны иметь заранее известный тип.
В роли таких значений, к примеру, могут выступать числовые литералы, так как их тип однозначно определяется суффиксом~\cite{fsharp_pfp_issue_5}. 
В листинге~\ref{lst:tech:type_inference} приведен простой пример:

\begin{lstlisting}[style=fsharpstyle,caption={Пример автоматического вывода типа функции}, label=lst:tech:type_inference]
> let add a b = a + b;;
val add : int -> int -> int
> add 3 5;;
val it : int = 8
\end{lstlisting}

Функция \lstinline!add! возвращает сумму своих параметров и имеет тип \lstinline!int -> int -> int!. 
Если не смотреть на сигнатуру функции, то можно подумать, что она складывает значения любых типов, но это не так. 
Попытка вызвать её для аргументов типа \lstinline!float! или \lstinline!decimal! приведёт к ошибке компиляции.
Причина такого поведения кроется в механизме вывода типов. 
Поскольку оператор \lstinline!+! может работать с разными типами данных, а никакой дополнительной информации о том, как эта функция будет использоваться, нет, компилятор по умолчанию приводит её к типу \lstinline!int -> int -> int!~\cite{fsharp_pfp_issue_5}.

В большинстве случаев автоматический вывод типов является очень удобным и способствует написанию полиморфный функций.
Алгоритм, используемый компилятором \fsharp{}, использует глобальный вывод типов и позволяет справляться даже с очень сложными типами.
Для демонстрации возможностей вывода типа для полиморфных функций рассмотрим классический пример "--- комбинаторный базис $SKI$~\cite[c.~21]{harrison_1997}:
\begin{align}
  I &= \lambda x . x \\
  K &= \lambda x\ y . x \\
  S &= \lambda f\ g\ x . (f\ x)(g\ x) \text{\,.}
\end{align}

Пример вывода интерактивного окружения \fsharp{} приведен в листинге~\ref{lst:tech:ski_basis}. 
Как можно заметить типы полученных функций довольно сложные, но компилятор смог их вывести.
\begin{lstlisting}[style=fsharpstyle,caption={Пример определения комбинаторного базиса $SKI$}, label=lst:tech:ski_basis]
> let I x = x;;
val I : x:'a -> 'a

> let K x y = x;;
val K : x:'a -> y:'b -> 'a

> let S f g x = (f x) (g x);;
val S : f:('a -> 'b -> 'c) -> g:('a -> 'b) -> x:'a -> 'c
\end{lstlisting}


Обычно при программировании на \fsharp{} в функциональном стиле нет необходимости указывать типы явно, транслятор сам назначит выражению наиболее общий тип.
Однако, иногда бывает полезно ограничить вывод типа. 
Подобная мера не заставит работать код, который до этого не работал, но может использоваться как документация для понимания его предназначения; также возможно использовать более короткие синонимы для сложных типов.
Ограничение типа может быть задано в \fsharp{} путём добавления аннотации типа после некоторого выражения. 
Аннотации типов состоят из двоеточия, за которым указан тип. 
Обычно расположение аннотаций не имеет значения; если они есть, то они заставляют компилятор использовать соответствующие ограничения~\cite[с.~59]{harrison_1997}. 


\subsubsection{Стратегии вычислений. }
\label{ssub:tech:eval_strategy_fsharp}
Обычно выражения в \fsharp{} вычисляются <<энергично>>. 
Это означает, что значение выражения будет вычислено независимо от того, используется оно где-либо или нет.
В противоположность жадному подходу существует стратегия ленивых вычислений, которая
позволяет вычислять значение выражения только тогда, когда оно становится необходимо. 
Преимуществами такого подхода являются:
\begin{itemize}
  \item производительность, поскольку неиспользуемые значения просто не вычисляются;
  \item возможность работать с бесконечными или очень большими последовательностями, так как они никогда не загружаются в память полностью;
  \item декларативность кода. Использование ленивых вычислений избавляет программиста от
необходимости следить за порядком вычислений, что делает код проще.
\end{itemize}

Главный недостаток ленивых вычислений "--- плохая предсказуемость.
В отличие от энергичных вычислений, где очень просто определить пространственную и временную сложность алгоритма, с ленивыми вычислениями всё может быть куда менее очевидно.
\fsharp{} позволяет программисту самостоятельно решать, что именно должно вычисляться лениво, а что нет.
Это в значительной степени устраняет проблему плохой предсказуемости, так как ленивые вычисления применяются только там, где это действительно необходимо, позволяя сочетать лучшее из обоих миров~\cite{fsharp_pfp_issue_5}.


\subsubsection{Сопоставление с образцом. }
\label{ssub:tech:pattern_matching}
Образец "--- это описание <<формы>> ожидаемой структуры данных: образец сам по себе похож на литерал структуры данных (т.\,е. он состоит из конструкторов алгебраических типов и литералов примитивных типов: целых, строковых и т.\,п.), однако может содержать метапеременные "--- <<дырки>>, обозначающие: <<значение, которое встретится в данном месте, назовем данным именем>>~\cite{pfp_funelem_issue3_2009}.
Сопоставление с образцом "--- основной способ работы со структурами данных в \fsharp{}.
Эта языковая конструкция состоит из ключевого слова \lstinline!match!, анализируемого выражения, ключевого слова \lstinline!with! и набора правил.
Каждое правило "--- это пара образец"=результат. 
Всё выражение сопоставления с образцом принимает значение того правила, образец которого соответствует анализируемому выражению. 
Все правила сопоставления с образцом должны возвращать значения одного и того же типа. 
В простейшем случае в качестве образцов могут выступать константы:
\begin{lstlisting}[style=fsharpstyle]
> let xor x y =
      match x, y with
      | true, true -> false
      | false, false -> false
      | true, false -> true
      | false, true -> true ;;
val xor : bool -> bool -> bool
\end{lstlisting}

В правилах сопоставления с образцом можно использовать символ подчеркивания, если конкретное значение неважно.
Если набор правил сопоставления не покрывает всевозможные значения образца, компилятор выдаёт предупреждение.
На этапе исполнения, если ни одно правило не будет соответствовать
образцу, будет сгенерировано исключение~\cite{fsharp_pfp_issue_5}.
Сопоставление с образцом очень мощный механизм, но иногда и его выразительности недостаточно для описание идеи.
Язык \fsharp{} вводит понятие активных шаблонов, когда шаблон может представлять из себя пользовательскую функцию, которая может содержать дополнительную логику обработки.


\subsubsection{Вычислительные выражения. }
\label{ssub:tech:compexpr}
Среди нововведений \fsharp{} можно особо выделить так называемые вычислительные выражения (com\-pu\-ta\-ti\-on expressions или workflows).
Они являются обобщением генераторов последовательности и, в частности, позволяют встраивать в \fsharp{} такие вычислительные структуры, как монады и моноиды. Также они могут быть применены для асинхронного программирования и создания DSL~\cite{fsharp_pfp_issue_5}.

Вычислительное выражение имеет форму блока, содержащего некоторый код на \fsharp{} в фигурных скобках.
Этому блоку должен предшествовать специальный объект, который называется еще построителем (builder).
Общая форма следующая: \lstinline[style=fsharpstyle]!builder { comp-expr }!.
Построитель определяет способ интерпретации того кода, который указан в фигурных скобках.
Сам код вычисления внешне почти не отличается от обычного кода на \fsharp{}, кроме того, что в нём нельзя определять новые типы, а также нельзя использовать изменяемые значения.
Вместо таких значений можно использовать ссылки, но делать это следует с большой осторожностью, поскольку вычислительные выражения обычно задают некие отложенные вычисления, а последние не очень любят побочные эффекты~\cite{fsharp_pfp_issue_5}.

\subsubsection{Асинхронные потоки операций. }
\label{ssub:tech:fsharp_async}
Асинхронные потоки операций "--- это один из самых интересных примеров практического использования вычислительных выражений.
Код, выполняющий какие-либо неблокирующие операции ввода"=вывода, как правило сложен для понимания, поскольку представляет из себя множество методов обратного вызова, каждый из которых обрабатывает какой-то промежуточный результат и возможно начинает новую асинхронную операцию.
Асинхронные потоки операций позволяют писать асинхронный код последовательно, не определяя методы обратного вызова явно.
Для создания асинхронного потока операций используется построитель \lstinline[style=fsharpstyle]!async!~\cite{fsharp_pfp_issue_5}